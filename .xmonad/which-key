#!/usr/bin/env nu

let storage_file = $"($env.HOME)/.local/share/dotfiles/kv_storage.nuon"

def store_key [key] {
  let value = $in

  let kv = if ($storage_file | path exists) {
    open $storage_file
  } else {
    $storage_file | path dirname | mkdir $in
    {}
  }

  let prev = $kv | get --optional $key
  let new_kv = $kv | upsert $key $value 

  $new_kv | save -f $storage_file
  $prev
}

def load_key [key] {
  let kv = if ($storage_file | path exists) {
    open $storage_file
  } else {
    $storage_file | path dirname | mkdir $in
    {}
  }
  $kv | get $key
}

def --wrapped xmonadctl [...$rest] {
  run-external $"($env.HOME)/.local/bin/xmonadctl" ...$rest
}

def pamix [] {
  let idx = job spawn {
    (^alacritty --class=xmonad-center-float
      -o window.dimensions.columns=80 -o window.dimensions.lines=20
      -e pamix)
    "done" | job send 0
  }
  # wait until pamix started and ready to handle input
  let win_id = do {
    mut pid = 0
    loop {
      sleep 100ms
      let pids = job list | where id == $idx | get pids | first
      if ($pids | is-not-empty) {
        $pid = ($pids | first | into int)
        break
      }
    }
    sleep 100ms
    xdotool search --pid $pid | into int
  }
  xdotool key --window $win_id F3
  job recv
}

def modify-transparenty [f] {
  let config = $"($env.HOME)/.config/alacritty/alacritty.toml"
  let template = $"($config).template"
  let opacity = open -r $config | parse "opacity = {x}" | first | get x | default 1.0 | into float
  let res = (do $f ($opacity * 100 | into int)) / 100
  nu $"($env.HOME)/.xmonad/expand-template" --file $template --vars ({opacity: $res} | to nuon)
}

def toggle-transparenty [] {
  modify-transparenty { |current|
    let old = $current | store_key "alacritty.opacity" | default 100
    if ($current >= 100) {
      if ($old < 100) { $old } else { 85 }
    } else {
      100
    }
  }
}

def less-transparenty [] { modify-transparenty { |x| if ($x >= 95) { 100 } else { $x + 05 } } }
def more-transparenty [] { modify-transparenty { |x| if ($x <= 5) { 0 } else { $x - 5 } } }
def less-brightness [] { run-external $"($env.HOME)/bin/adjust-brightness" "-" }
def more-brightness [] { run-external $"($env.HOME)/bin/adjust-brightness" "+" }

let keys = {
  a: {
    group: adjust
    keys: {
      v: [volume { || pamix }]
    }
  }
  d: {
    group: decrease
    keys: {
      t: [transparency { || less-transparenty }]
      b: [brightness { || less-brightness }]
    }
  }
  i: {
    group: increase
    keys: {
      t: [transparency { || more-transparenty }]
      b: [brightness { || more-brightness }]
    }
  }
  l: {
    group: layout
    keys: {
      l: [next { || xmonadctl "layout-next" }]
      m: [maximized { || xmonadctl "layout-set-full" }]
      t: [tall { || xmonadctl "layout-set-tall" }]
      f: ["maximize focused" { || xmonadctl "layout-toggle-focused-maximize" }]
      x: ["toggle float (eXclude from tiling)" { || xmonadctl "layout-toggle-float" }]
    }
  }
  s: {
    group: style
    keys: {
      d: [dark { || nu $"($env.HOME)/.xmonad/theme-switcher" set dark }]
      l: [light { || nu $"($env.HOME)/.xmonad/theme-switcher" set light }]
    }
  }
  t: {
    group: toggle
    keys: {
      t: [transparency { || toggle-transparenty }]
      d: [docks { || run-external $"($env.HOME)/.xmonad/toggle-xmobar" }]
    }
  }
}

let key_list = flatten_keys [] "" "" { group: "", keys: $keys }

def flatten_keys [res acc_key acc_desc value] {
  match ($value | describe -d | get type) {
    "list" => ($res | append {key: $acc_key, desc: $"($acc_desc) ($value | first)", act: ($value | get 1)}),
    "record" => {
      let $group = $value.group
      $value.keys
      | items { |k, v| {key: $k, value: $v} }
      | reduce --fold $res { |$x, fold|
        flatten_keys $fold $"($acc_key)($x.key)" $"($acc_desc) ($group)" $x.value
      }
    }
  }
}

def open_menu [] {
  each { $"($in.key)\t($in.desc)" } | to text | (/usr/bin/rofi
    -dmenu
    -window-title "Which key"
    -cycle
    -matching regex
    -selected-row
    -format i
    -filter "^"
    -auto-select
  )
}

def interact [] {
  let selection = $key_list | open_menu | into int
  $key_list | get $selection
}

def main [] {
  let res = interact

  $res.key | store_key "which-key.last-action"

  do $res.act
  ignore
}

def "main repeat" [] {
  let last_action = load_key "which-key.last-action"
  if ($last_action | is-not-empty) {
    $key_list | where key == $last_action | first | each {
      do $in.act
    }
  }
}


